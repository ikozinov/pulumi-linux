// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;
using Ipvs;

namespace Pulumi.Linux.Ipvs
{
    /// <summary>
    /// Virtual service serves requests to real servers (backends)
    /// </summary>
    [LinuxResourceType("linux:ipvs:Service")]
    public partial class Service : global::Pulumi.ComponentResource
    {
        [Output("backends")]
        public Output<ImmutableArray<Outputs.Backend>> Backends { get; private set; } = null!;

        /// <summary>
        /// The host of the service-address. Host may be one of a plain IP address or a hostname.
        /// </summary>
        [Output("host")]
        public Output<string> Host { get; private set; } = null!;

        /// <summary>
        /// Granularity with which clients are grouped for persistent virtual services. The source address of the request is masked with this netmask to direct all clients from a network to the same real server.
        /// </summary>
        [Output("netmask")]
        public Output<string> Netmask { get; private set; } = null!;

        /// <summary>
        /// Virtual service persistence timeout in seconds. Multiple requests from a client are redirected to the same real server selected for the first request.
        /// </summary>
        [Output("persistence")]
        public Output<int?> Persistence { get; private set; } = null!;

        /// <summary>
        /// The port of the service-address.
        /// </summary>
        [Output("port")]
        public Output<int> Port { get; private set; } = null!;

        /// <summary>
        /// Algorithm for allocating TCP connections and UDP datagrams to real servers.
        /// rr - Round Robin: distributes jobs equally amongst the available real servers.
        /// wrr - Weighted Round Robin: assigns jobs to real servers proportionally to there real servers' weight. Servers with higher weights receive new jobs first and get more jobs than servers with lower weights. Servers with equal weights get an equal distribution of new jobs.
        /// lc - Least-Connection: assigns more jobs to real servers with fewer active jobs.
        /// wlc - Weighted Least-Connection: assigns more jobs to servers with fewer jobs and relative to the real servers' weight (Ci/Wi). This is the default.
        /// lblc - Locality-Based Least-Connection: assigns jobs destined for the same IP address to the same server if the server is not overloaded and available; otherwise assign jobs to servers with fewer jobs, and keep it for future assignment.
        /// lblcr - Locality-Based Least-Connection with Replication: assigns jobs destined for the same IP address to the least-connection node in the server set for the IP address. If all the node in the server set are over loaded, it picks up a node with fewer jobs in the cluster and adds it in the sever set for the target. If the server set has not been modified for the specified time, the most loaded node is removed from the server set, in order to avoid high degree of replication.
        /// dh - Destination Hashing: assigns jobs to servers through looking up a statically assigned hash table by their destination IP addresses.
        /// sh - Source Hashing: assigns jobs to servers through looking up a statically assigned hash table by their source IP addresses.
        /// sed - Shortest Expected Delay: assigns an incoming job to the server with the shortest expected delay. The expected delay that the job will experience is (Ci + 1) / Ui if sent to the ith server, in which Ci is the number of jobs on the the ith server and Ui is the fixed service rate (weight) of the ith server.
        /// nq - Never Queue: assigns an incoming job to an idle server if there is, instead of waiting for a fast one; if all the servers are busy, it adopts the Shortest Expected Delay policy to assign the job.
        /// </summary>
        [Output("scheduler")]
        public Output<string> Scheduler { get; private set; } = null!;

        /// <summary>
        /// Service type, one of the tcp, udp, fwmark
        /// </summary>
        [Output("type")]
        public Output<string> Type { get; private set; } = null!;


        /// <summary>
        /// Create a Service resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public Service(string name, ServiceArgs args, ComponentResourceOptions? options = null)
            : base("linux:ipvs:Service", name, args ?? new ServiceArgs(), MakeResourceOptions(options, ""), remote: true)
        {
        }

        private static ComponentResourceOptions MakeResourceOptions(ComponentResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new ComponentResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = ComponentResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
    }

    public sealed class ServiceArgs : global::Pulumi.ResourceArgs
    {
        [Input("backends", required: true)]
        private InputList<Inputs.BackendArgs>? _backends;
        public InputList<Inputs.BackendArgs> Backends
        {
            get => _backends ?? (_backends = new InputList<Inputs.BackendArgs>());
            set => _backends = value;
        }

        /// <summary>
        /// The host of the service-address. Host may be one of a plain IP address or a hostname.
        /// </summary>
        [Input("host", required: true)]
        public Input<string> Host { get; set; } = null!;

        /// <summary>
        /// Target instance for IPVS management
        /// </summary>
        [Input("instance", required: true)]
        public Input<Pulumi.Linux.Ipvs> Instance { get; set; } = null!;

        /// <summary>
        /// Specify the granularity with which clients are grouped for persistent virtual services. The source address of the request is masked with this netmask to direct all clients from a network to the same real server. The default is 255.255.255.255, that is, the persistence granularity is per client host. Less specific netmasks may be used to resolve problems with non-persistent cache clusters on the client side. IPv6 netmasks should be specified as a prefix length between 1 and 128. The default prefix length is 128.  
        /// </summary>
        [Input("netmask", required: true)]
        public Input<string> Netmask { get; set; } = null!;

        /// <summary>
        /// Specify that a virtual service is persistent. If this option is specified, multiple requests from a client are redirected to the same real server selected for the first request. Optionally, the timeout of persistent sessions may be specified given in seconds, otherwise the default of 300 seconds will be used. This option may be used in conjunction with protocols such as SSL or FTP where it is important that clients consistently connect with the same real server.
        /// Note: If a virtual service is to handle FTP connections then persistence must be set for the virtual service if Direct Routing or Tunnelling is used as the forwarding mechanism. If Masquerading is used in conjunction with an FTP service than persistence is not necessary, but the ip_vs_ftp kernel module must be used. This module may be manually inserted into the kernel using insmod(8).
        /// </summary>
        [Input("persistence")]
        public Input<int>? Persistence { get; set; }

        /// <summary>
        /// The port of the service-address. The Port may be omitted, in which case zero will be used. A Port of zero is only valid if the service is persistent, in which case it is a wild-card port, that is connections will be accepted to any port.
        /// </summary>
        [Input("port", required: true)]
        public Input<int> Port { get; set; } = null!;

        /// <summary>
        /// Algorithm for allocating TCP connections and UDP datagrams to real servers. Scheduling algorithms are implemented as kernel modules. Ten are shipped with the Linux Virtual Server:
        /// rr - Round Robin: distributes jobs equally amongst the available real servers.
        /// wrr - Weighted Round Robin: assigns jobs to real servers proportionally to there real servers' weight. Servers with higher weights receive new jobs first and get more jobs than servers with lower weights. Servers with equal weights get an equal distribution of new jobs.
        /// lc - Least-Connection: assigns more jobs to real servers with fewer active jobs.
        /// wlc - Weighted Least-Connection: assigns more jobs to servers with fewer jobs and relative to the real servers' weight (Ci/Wi). This is the default.
        /// lblc - Locality-Based Least-Connection: assigns jobs destined for the same IP address to the same server if the server is not overloaded and available; otherwise assign jobs to servers with fewer jobs, and keep it for future assignment.
        /// lblcr - Locality-Based Least-Connection with Replication: assigns jobs destined for the same IP address to the least-connection node in the server set for the IP address. If all the node in the server set are over loaded, it picks up a node with fewer jobs in the cluster and adds it in the sever set for the target. If the server set has not been modified for the specified time, the most loaded node is removed from the server set, in order to avoid high degree of replication.
        /// dh - Destination Hashing: assigns jobs to servers through looking up a statically assigned hash table by their destination IP addresses.
        /// sh - Source Hashing: assigns jobs to servers through looking up a statically assigned hash table by their source IP addresses.
        /// sed - Shortest Expected Delay: assigns an incoming job to the server with the shortest expected delay. The expected delay that the job will experience is (Ci + 1) / Ui if sent to the ith server, in which Ci is the number of jobs on the the ith server and Ui is the fixed service rate (weight) of the ith server.
        /// nq - Never Queue: assigns an incoming job to an idle server if there is, instead of waiting for a fast one; if all the servers are busy, it adopts the Shortest Expected Delay policy to assign the job.
        /// </summary>
        [Input("scheduler", required: true)]
        public Input<string> Scheduler { get; set; } = null!;

        /// <summary>
        /// Service type, one of the tcp, udp, fwmark. Default is tcp.
        ///  Use a firewall-mark, an integer value greater than zero, to denote a virtual service instead of an address, port and protocol (UDP or TCP). The marking of packets with a firewall-mark is configured using the -m|--mark option to iptables. It can be used to build a virtual service assoicated with the same real servers, covering multiple IP address, port and protocol tripplets. If IPv6 addresses are used, the -6 option must be used.
        /// Using firewall-mark virtual services provides a convenient method of grouping together different IP addresses, ports and protocols into a single virtual service. This is useful for both simplifying configuration if a large number of virtual services are required and grouping persistence across what would otherwise be multiple virtual services.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        public ServiceArgs()
        {
            Netmask = "255.255.255.255";
            Scheduler = "wlc";
            Type = "tcp";
        }
        public static new ServiceArgs Empty => new ServiceArgs();
    }
}
