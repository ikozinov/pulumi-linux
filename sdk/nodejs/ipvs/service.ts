// *** WARNING: this file was generated by pulumigen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";
import * as utilities from "../utilities";

import {Ipvs} from "..";

/**
 * Virtual service serves requests to real servers (backends)
 */
export class Service extends pulumi.ComponentResource {
    /** @internal */
    public static readonly __pulumiType = 'linux:ipvs:Service';

    /**
     * Returns true if the given object is an instance of Service.  This is designed to work even
     * when multiple copies of the Pulumi SDK have been loaded into the same process.
     */
    public static isInstance(obj: any): obj is Service {
        if (obj === undefined || obj === null) {
            return false;
        }
        return obj['__pulumiType'] === Service.__pulumiType;
    }

    public readonly backends!: pulumi.Output<outputs.ipvs.Backend[]>;
    /**
     * The host of the service-address. Host may be one of a plain IP address or a hostname.
     */
    public readonly host!: pulumi.Output<string>;
    /**
     * Granularity with which clients are grouped for persistent virtual services. The source address of the request is masked with this netmask to direct all clients from a network to the same real server.
     */
    public readonly netmask!: pulumi.Output<string>;
    /**
     * Virtual service persistence timeout in seconds. Multiple requests from a client are redirected to the same real server selected for the first request.
     */
    public readonly persistence!: pulumi.Output<number | undefined>;
    /**
     * The port of the service-address.
     */
    public readonly port!: pulumi.Output<number>;
    /**
     * Algorithm for allocating TCP connections and UDP datagrams to real servers.
     * rr - Round Robin: distributes jobs equally amongst the available real servers.
     * wrr - Weighted Round Robin: assigns jobs to real servers proportionally to there real servers' weight. Servers with higher weights receive new jobs first and get more jobs than servers with lower weights. Servers with equal weights get an equal distribution of new jobs.
     * lc - Least-Connection: assigns more jobs to real servers with fewer active jobs.
     * wlc - Weighted Least-Connection: assigns more jobs to servers with fewer jobs and relative to the real servers' weight (Ci/Wi). This is the default.
     * lblc - Locality-Based Least-Connection: assigns jobs destined for the same IP address to the same server if the server is not overloaded and available; otherwise assign jobs to servers with fewer jobs, and keep it for future assignment.
     * lblcr - Locality-Based Least-Connection with Replication: assigns jobs destined for the same IP address to the least-connection node in the server set for the IP address. If all the node in the server set are over loaded, it picks up a node with fewer jobs in the cluster and adds it in the sever set for the target. If the server set has not been modified for the specified time, the most loaded node is removed from the server set, in order to avoid high degree of replication.
     * dh - Destination Hashing: assigns jobs to servers through looking up a statically assigned hash table by their destination IP addresses.
     * sh - Source Hashing: assigns jobs to servers through looking up a statically assigned hash table by their source IP addresses.
     * sed - Shortest Expected Delay: assigns an incoming job to the server with the shortest expected delay. The expected delay that the job will experience is (Ci + 1) / Ui if sent to the ith server, in which Ci is the number of jobs on the the ith server and Ui is the fixed service rate (weight) of the ith server.
     * nq - Never Queue: assigns an incoming job to an idle server if there is, instead of waiting for a fast one; if all the servers are busy, it adopts the Shortest Expected Delay policy to assign the job.
     */
    public readonly scheduler!: pulumi.Output<string>;
    /**
     * Service type, one of the tcp, udp, fwmark
     */
    public readonly type!: pulumi.Output<string>;

    /**
     * Create a Service resource with the given unique name, arguments, and options.
     *
     * @param name The _unique_ name of the resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param opts A bag of options that control this resource's behavior.
     */
    constructor(name: string, args: ServiceArgs, opts?: pulumi.ComponentResourceOptions) {
        let resourceInputs: pulumi.Inputs = {};
        opts = opts || {};
        if (!opts.id) {
            if ((!args || args.backends === undefined) && !opts.urn) {
                throw new Error("Missing required property 'backends'");
            }
            if ((!args || args.host === undefined) && !opts.urn) {
                throw new Error("Missing required property 'host'");
            }
            if ((!args || args.instance === undefined) && !opts.urn) {
                throw new Error("Missing required property 'instance'");
            }
            if ((!args || args.netmask === undefined) && !opts.urn) {
                throw new Error("Missing required property 'netmask'");
            }
            if ((!args || args.port === undefined) && !opts.urn) {
                throw new Error("Missing required property 'port'");
            }
            if ((!args || args.scheduler === undefined) && !opts.urn) {
                throw new Error("Missing required property 'scheduler'");
            }
            if ((!args || args.type === undefined) && !opts.urn) {
                throw new Error("Missing required property 'type'");
            }
            resourceInputs["backends"] = args ? args.backends : undefined;
            resourceInputs["host"] = args ? args.host : undefined;
            resourceInputs["instance"] = args ? args.instance : undefined;
            resourceInputs["netmask"] = (args ? args.netmask : undefined) ?? "255.255.255.255";
            resourceInputs["persistence"] = args ? args.persistence : undefined;
            resourceInputs["port"] = args ? args.port : undefined;
            resourceInputs["scheduler"] = (args ? args.scheduler : undefined) ?? "wlc";
            resourceInputs["type"] = (args ? args.type : undefined) ?? "tcp";
        } else {
            resourceInputs["backends"] = undefined /*out*/;
            resourceInputs["host"] = undefined /*out*/;
            resourceInputs["netmask"] = undefined /*out*/;
            resourceInputs["persistence"] = undefined /*out*/;
            resourceInputs["port"] = undefined /*out*/;
            resourceInputs["scheduler"] = undefined /*out*/;
            resourceInputs["type"] = undefined /*out*/;
        }
        opts = pulumi.mergeOptions(utilities.resourceOptsDefaults(), opts);
        super(Service.__pulumiType, name, resourceInputs, opts, true /*remote*/);
    }
}

/**
 * The set of arguments for constructing a Service resource.
 */
export interface ServiceArgs {
    backends: pulumi.Input<pulumi.Input<inputs.ipvs.BackendArgs>[]>;
    /**
     * The host of the service-address. Host may be one of a plain IP address or a hostname.
     */
    host: pulumi.Input<string>;
    /**
     * Target instance for IPVS management
     */
    instance: pulumi.Input<Ipvs>;
    /**
     * Specify the granularity with which clients are grouped for persistent virtual services. The source address of the request is masked with this netmask to direct all clients from a network to the same real server. The default is 255.255.255.255, that is, the persistence granularity is per client host. Less specific netmasks may be used to resolve problems with non-persistent cache clusters on the client side. IPv6 netmasks should be specified as a prefix length between 1 and 128. The default prefix length is 128.  
     */
    netmask: pulumi.Input<string>;
    /**
     * Specify that a virtual service is persistent. If this option is specified, multiple requests from a client are redirected to the same real server selected for the first request. Optionally, the timeout of persistent sessions may be specified given in seconds, otherwise the default of 300 seconds will be used. This option may be used in conjunction with protocols such as SSL or FTP where it is important that clients consistently connect with the same real server.
     * Note: If a virtual service is to handle FTP connections then persistence must be set for the virtual service if Direct Routing or Tunnelling is used as the forwarding mechanism. If Masquerading is used in conjunction with an FTP service than persistence is not necessary, but the ip_vs_ftp kernel module must be used. This module may be manually inserted into the kernel using insmod(8).
     */
    persistence?: pulumi.Input<number>;
    /**
     * The port of the service-address. The Port may be omitted, in which case zero will be used. A Port of zero is only valid if the service is persistent, in which case it is a wild-card port, that is connections will be accepted to any port.
     */
    port: pulumi.Input<number>;
    /**
     * Algorithm for allocating TCP connections and UDP datagrams to real servers. Scheduling algorithms are implemented as kernel modules. Ten are shipped with the Linux Virtual Server:
     * rr - Round Robin: distributes jobs equally amongst the available real servers.
     * wrr - Weighted Round Robin: assigns jobs to real servers proportionally to there real servers' weight. Servers with higher weights receive new jobs first and get more jobs than servers with lower weights. Servers with equal weights get an equal distribution of new jobs.
     * lc - Least-Connection: assigns more jobs to real servers with fewer active jobs.
     * wlc - Weighted Least-Connection: assigns more jobs to servers with fewer jobs and relative to the real servers' weight (Ci/Wi). This is the default.
     * lblc - Locality-Based Least-Connection: assigns jobs destined for the same IP address to the same server if the server is not overloaded and available; otherwise assign jobs to servers with fewer jobs, and keep it for future assignment.
     * lblcr - Locality-Based Least-Connection with Replication: assigns jobs destined for the same IP address to the least-connection node in the server set for the IP address. If all the node in the server set are over loaded, it picks up a node with fewer jobs in the cluster and adds it in the sever set for the target. If the server set has not been modified for the specified time, the most loaded node is removed from the server set, in order to avoid high degree of replication.
     * dh - Destination Hashing: assigns jobs to servers through looking up a statically assigned hash table by their destination IP addresses.
     * sh - Source Hashing: assigns jobs to servers through looking up a statically assigned hash table by their source IP addresses.
     * sed - Shortest Expected Delay: assigns an incoming job to the server with the shortest expected delay. The expected delay that the job will experience is (Ci + 1) / Ui if sent to the ith server, in which Ci is the number of jobs on the the ith server and Ui is the fixed service rate (weight) of the ith server.
     * nq - Never Queue: assigns an incoming job to an idle server if there is, instead of waiting for a fast one; if all the servers are busy, it adopts the Shortest Expected Delay policy to assign the job.
     */
    scheduler: pulumi.Input<string>;
    /**
     * Service type, one of the tcp, udp, fwmark. Default is tcp.
     *  Use a firewall-mark, an integer value greater than zero, to denote a virtual service instead of an address, port and protocol (UDP or TCP). The marking of packets with a firewall-mark is configured using the -m|--mark option to iptables. It can be used to build a virtual service assoicated with the same real servers, covering multiple IP address, port and protocol tripplets. If IPv6 addresses are used, the -6 option must be used.
     * Using firewall-mark virtual services provides a convenient method of grouping together different IP addresses, ports and protocols into a single virtual service. This is useful for both simplifying configuration if a large number of virtual services are required and grouping persistence across what would otherwise be multiple virtual services.
     */
    type: pulumi.Input<string>;
}
