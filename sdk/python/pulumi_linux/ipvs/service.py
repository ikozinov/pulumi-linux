# coding=utf-8
# *** WARNING: this file was generated by pulumigen. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ..ipvs import Ipvs
from ._inputs import *

__all__ = ['ServiceArgs', 'Service']

@pulumi.input_type
class ServiceArgs:
    def __init__(__self__, *,
                 backends: pulumi.Input[Sequence[pulumi.Input['BackendArgs']]],
                 host: pulumi.Input[str],
                 instance: pulumi.Input['Ipvs'],
                 netmask: pulumi.Input[str],
                 port: pulumi.Input[int],
                 scheduler: pulumi.Input[str],
                 type: pulumi.Input[str],
                 persistence: Optional[pulumi.Input[int]] = None):
        """
        The set of arguments for constructing a Service resource.
        :param pulumi.Input[str] host: The host of the service-address. Host may be one of a plain IP address or a hostname.
        :param pulumi.Input['Ipvs'] instance: Target instance for IPVS management
        :param pulumi.Input[str] netmask: Specify the granularity with which clients are grouped for persistent virtual services. The source address of the request is masked with this netmask to direct all clients from a network to the same real server. The default is 255.255.255.255, that is, the persistence granularity is per client host. Less specific netmasks may be used to resolve problems with non-persistent cache clusters on the client side. IPv6 netmasks should be specified as a prefix length between 1 and 128. The default prefix length is 128.  
        :param pulumi.Input[int] port: The port of the service-address. The Port may be omitted, in which case zero will be used. A Port of zero is only valid if the service is persistent, in which case it is a wild-card port, that is connections will be accepted to any port.
        :param pulumi.Input[str] scheduler: Algorithm for allocating TCP connections and UDP datagrams to real servers. Scheduling algorithms are implemented as kernel modules. Ten are shipped with the Linux Virtual Server:
               rr - Round Robin: distributes jobs equally amongst the available real servers.
               wrr - Weighted Round Robin: assigns jobs to real servers proportionally to there real servers' weight. Servers with higher weights receive new jobs first and get more jobs than servers with lower weights. Servers with equal weights get an equal distribution of new jobs.
               lc - Least-Connection: assigns more jobs to real servers with fewer active jobs.
               wlc - Weighted Least-Connection: assigns more jobs to servers with fewer jobs and relative to the real servers' weight (Ci/Wi). This is the default.
               lblc - Locality-Based Least-Connection: assigns jobs destined for the same IP address to the same server if the server is not overloaded and available; otherwise assign jobs to servers with fewer jobs, and keep it for future assignment.
               lblcr - Locality-Based Least-Connection with Replication: assigns jobs destined for the same IP address to the least-connection node in the server set for the IP address. If all the node in the server set are over loaded, it picks up a node with fewer jobs in the cluster and adds it in the sever set for the target. If the server set has not been modified for the specified time, the most loaded node is removed from the server set, in order to avoid high degree of replication.
               dh - Destination Hashing: assigns jobs to servers through looking up a statically assigned hash table by their destination IP addresses.
               sh - Source Hashing: assigns jobs to servers through looking up a statically assigned hash table by their source IP addresses.
               sed - Shortest Expected Delay: assigns an incoming job to the server with the shortest expected delay. The expected delay that the job will experience is (Ci + 1) / Ui if sent to the ith server, in which Ci is the number of jobs on the the ith server and Ui is the fixed service rate (weight) of the ith server.
               nq - Never Queue: assigns an incoming job to an idle server if there is, instead of waiting for a fast one; if all the servers are busy, it adopts the Shortest Expected Delay policy to assign the job.
        :param pulumi.Input[str] type: Service type, one of the tcp, udp, fwmark. Default is tcp.
                Use a firewall-mark, an integer value greater than zero, to denote a virtual service instead of an address, port and protocol (UDP or TCP). The marking of packets with a firewall-mark is configured using the -m|--mark option to iptables. It can be used to build a virtual service assoicated with the same real servers, covering multiple IP address, port and protocol tripplets. If IPv6 addresses are used, the -6 option must be used.
               Using firewall-mark virtual services provides a convenient method of grouping together different IP addresses, ports and protocols into a single virtual service. This is useful for both simplifying configuration if a large number of virtual services are required and grouping persistence across what would otherwise be multiple virtual services.
        :param pulumi.Input[int] persistence: Specify that a virtual service is persistent. If this option is specified, multiple requests from a client are redirected to the same real server selected for the first request. Optionally, the timeout of persistent sessions may be specified given in seconds, otherwise the default of 300 seconds will be used. This option may be used in conjunction with protocols such as SSL or FTP where it is important that clients consistently connect with the same real server.
               Note: If a virtual service is to handle FTP connections then persistence must be set for the virtual service if Direct Routing or Tunnelling is used as the forwarding mechanism. If Masquerading is used in conjunction with an FTP service than persistence is not necessary, but the ip_vs_ftp kernel module must be used. This module may be manually inserted into the kernel using insmod(8).
        """
        pulumi.set(__self__, "backends", backends)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "instance", instance)
        if netmask is None:
            netmask = '255.255.255.255'
        pulumi.set(__self__, "netmask", netmask)
        pulumi.set(__self__, "port", port)
        if scheduler is None:
            scheduler = 'wlc'
        pulumi.set(__self__, "scheduler", scheduler)
        if type is None:
            type = 'tcp'
        pulumi.set(__self__, "type", type)
        if persistence is not None:
            pulumi.set(__self__, "persistence", persistence)

    @property
    @pulumi.getter
    def backends(self) -> pulumi.Input[Sequence[pulumi.Input['BackendArgs']]]:
        return pulumi.get(self, "backends")

    @backends.setter
    def backends(self, value: pulumi.Input[Sequence[pulumi.Input['BackendArgs']]]):
        pulumi.set(self, "backends", value)

    @property
    @pulumi.getter
    def host(self) -> pulumi.Input[str]:
        """
        The host of the service-address. Host may be one of a plain IP address or a hostname.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[str]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter
    def instance(self) -> pulumi.Input['Ipvs']:
        """
        Target instance for IPVS management
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: pulumi.Input['Ipvs']):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter
    def netmask(self) -> pulumi.Input[str]:
        """
        Specify the granularity with which clients are grouped for persistent virtual services. The source address of the request is masked with this netmask to direct all clients from a network to the same real server. The default is 255.255.255.255, that is, the persistence granularity is per client host. Less specific netmasks may be used to resolve problems with non-persistent cache clusters on the client side. IPv6 netmasks should be specified as a prefix length between 1 and 128. The default prefix length is 128.  
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: pulumi.Input[str]):
        pulumi.set(self, "netmask", value)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        The port of the service-address. The Port may be omitted, in which case zero will be used. A Port of zero is only valid if the service is persistent, in which case it is a wild-card port, that is connections will be accepted to any port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def scheduler(self) -> pulumi.Input[str]:
        """
        Algorithm for allocating TCP connections and UDP datagrams to real servers. Scheduling algorithms are implemented as kernel modules. Ten are shipped with the Linux Virtual Server:
        rr - Round Robin: distributes jobs equally amongst the available real servers.
        wrr - Weighted Round Robin: assigns jobs to real servers proportionally to there real servers' weight. Servers with higher weights receive new jobs first and get more jobs than servers with lower weights. Servers with equal weights get an equal distribution of new jobs.
        lc - Least-Connection: assigns more jobs to real servers with fewer active jobs.
        wlc - Weighted Least-Connection: assigns more jobs to servers with fewer jobs and relative to the real servers' weight (Ci/Wi). This is the default.
        lblc - Locality-Based Least-Connection: assigns jobs destined for the same IP address to the same server if the server is not overloaded and available; otherwise assign jobs to servers with fewer jobs, and keep it for future assignment.
        lblcr - Locality-Based Least-Connection with Replication: assigns jobs destined for the same IP address to the least-connection node in the server set for the IP address. If all the node in the server set are over loaded, it picks up a node with fewer jobs in the cluster and adds it in the sever set for the target. If the server set has not been modified for the specified time, the most loaded node is removed from the server set, in order to avoid high degree of replication.
        dh - Destination Hashing: assigns jobs to servers through looking up a statically assigned hash table by their destination IP addresses.
        sh - Source Hashing: assigns jobs to servers through looking up a statically assigned hash table by their source IP addresses.
        sed - Shortest Expected Delay: assigns an incoming job to the server with the shortest expected delay. The expected delay that the job will experience is (Ci + 1) / Ui if sent to the ith server, in which Ci is the number of jobs on the the ith server and Ui is the fixed service rate (weight) of the ith server.
        nq - Never Queue: assigns an incoming job to an idle server if there is, instead of waiting for a fast one; if all the servers are busy, it adopts the Shortest Expected Delay policy to assign the job.
        """
        return pulumi.get(self, "scheduler")

    @scheduler.setter
    def scheduler(self, value: pulumi.Input[str]):
        pulumi.set(self, "scheduler", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Service type, one of the tcp, udp, fwmark. Default is tcp.
         Use a firewall-mark, an integer value greater than zero, to denote a virtual service instead of an address, port and protocol (UDP or TCP). The marking of packets with a firewall-mark is configured using the -m|--mark option to iptables. It can be used to build a virtual service assoicated with the same real servers, covering multiple IP address, port and protocol tripplets. If IPv6 addresses are used, the -6 option must be used.
        Using firewall-mark virtual services provides a convenient method of grouping together different IP addresses, ports and protocols into a single virtual service. This is useful for both simplifying configuration if a large number of virtual services are required and grouping persistence across what would otherwise be multiple virtual services.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def persistence(self) -> Optional[pulumi.Input[int]]:
        """
        Specify that a virtual service is persistent. If this option is specified, multiple requests from a client are redirected to the same real server selected for the first request. Optionally, the timeout of persistent sessions may be specified given in seconds, otherwise the default of 300 seconds will be used. This option may be used in conjunction with protocols such as SSL or FTP where it is important that clients consistently connect with the same real server.
        Note: If a virtual service is to handle FTP connections then persistence must be set for the virtual service if Direct Routing or Tunnelling is used as the forwarding mechanism. If Masquerading is used in conjunction with an FTP service than persistence is not necessary, but the ip_vs_ftp kernel module must be used. This module may be manually inserted into the kernel using insmod(8).
        """
        return pulumi.get(self, "persistence")

    @persistence.setter
    def persistence(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "persistence", value)


class Service(pulumi.ComponentResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 backends: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['BackendArgs']]]]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 instance: Optional[pulumi.Input['Ipvs']] = None,
                 netmask: Optional[pulumi.Input[str]] = None,
                 persistence: Optional[pulumi.Input[int]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheduler: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        Virtual service serves requests to real servers (backends)

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[str] host: The host of the service-address. Host may be one of a plain IP address or a hostname.
        :param pulumi.Input['Ipvs'] instance: Target instance for IPVS management
        :param pulumi.Input[str] netmask: Specify the granularity with which clients are grouped for persistent virtual services. The source address of the request is masked with this netmask to direct all clients from a network to the same real server. The default is 255.255.255.255, that is, the persistence granularity is per client host. Less specific netmasks may be used to resolve problems with non-persistent cache clusters on the client side. IPv6 netmasks should be specified as a prefix length between 1 and 128. The default prefix length is 128.  
        :param pulumi.Input[int] persistence: Specify that a virtual service is persistent. If this option is specified, multiple requests from a client are redirected to the same real server selected for the first request. Optionally, the timeout of persistent sessions may be specified given in seconds, otherwise the default of 300 seconds will be used. This option may be used in conjunction with protocols such as SSL or FTP where it is important that clients consistently connect with the same real server.
               Note: If a virtual service is to handle FTP connections then persistence must be set for the virtual service if Direct Routing or Tunnelling is used as the forwarding mechanism. If Masquerading is used in conjunction with an FTP service than persistence is not necessary, but the ip_vs_ftp kernel module must be used. This module may be manually inserted into the kernel using insmod(8).
        :param pulumi.Input[int] port: The port of the service-address. The Port may be omitted, in which case zero will be used. A Port of zero is only valid if the service is persistent, in which case it is a wild-card port, that is connections will be accepted to any port.
        :param pulumi.Input[str] scheduler: Algorithm for allocating TCP connections and UDP datagrams to real servers. Scheduling algorithms are implemented as kernel modules. Ten are shipped with the Linux Virtual Server:
               rr - Round Robin: distributes jobs equally amongst the available real servers.
               wrr - Weighted Round Robin: assigns jobs to real servers proportionally to there real servers' weight. Servers with higher weights receive new jobs first and get more jobs than servers with lower weights. Servers with equal weights get an equal distribution of new jobs.
               lc - Least-Connection: assigns more jobs to real servers with fewer active jobs.
               wlc - Weighted Least-Connection: assigns more jobs to servers with fewer jobs and relative to the real servers' weight (Ci/Wi). This is the default.
               lblc - Locality-Based Least-Connection: assigns jobs destined for the same IP address to the same server if the server is not overloaded and available; otherwise assign jobs to servers with fewer jobs, and keep it for future assignment.
               lblcr - Locality-Based Least-Connection with Replication: assigns jobs destined for the same IP address to the least-connection node in the server set for the IP address. If all the node in the server set are over loaded, it picks up a node with fewer jobs in the cluster and adds it in the sever set for the target. If the server set has not been modified for the specified time, the most loaded node is removed from the server set, in order to avoid high degree of replication.
               dh - Destination Hashing: assigns jobs to servers through looking up a statically assigned hash table by their destination IP addresses.
               sh - Source Hashing: assigns jobs to servers through looking up a statically assigned hash table by their source IP addresses.
               sed - Shortest Expected Delay: assigns an incoming job to the server with the shortest expected delay. The expected delay that the job will experience is (Ci + 1) / Ui if sent to the ith server, in which Ci is the number of jobs on the the ith server and Ui is the fixed service rate (weight) of the ith server.
               nq - Never Queue: assigns an incoming job to an idle server if there is, instead of waiting for a fast one; if all the servers are busy, it adopts the Shortest Expected Delay policy to assign the job.
        :param pulumi.Input[str] type: Service type, one of the tcp, udp, fwmark. Default is tcp.
                Use a firewall-mark, an integer value greater than zero, to denote a virtual service instead of an address, port and protocol (UDP or TCP). The marking of packets with a firewall-mark is configured using the -m|--mark option to iptables. It can be used to build a virtual service assoicated with the same real servers, covering multiple IP address, port and protocol tripplets. If IPv6 addresses are used, the -6 option must be used.
               Using firewall-mark virtual services provides a convenient method of grouping together different IP addresses, ports and protocols into a single virtual service. This is useful for both simplifying configuration if a large number of virtual services are required and grouping persistence across what would otherwise be multiple virtual services.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: ServiceArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        Virtual service serves requests to real servers (backends)

        :param str resource_name: The name of the resource.
        :param ServiceArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(ServiceArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 backends: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['BackendArgs']]]]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 instance: Optional[pulumi.Input['Ipvs']] = None,
                 netmask: Optional[pulumi.Input[str]] = None,
                 persistence: Optional[pulumi.Input[int]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 scheduler: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is not None:
            raise ValueError('ComponentResource classes do not support opts.id')
        else:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = ServiceArgs.__new__(ServiceArgs)

            if backends is None and not opts.urn:
                raise TypeError("Missing required property 'backends'")
            __props__.__dict__["backends"] = backends
            if host is None and not opts.urn:
                raise TypeError("Missing required property 'host'")
            __props__.__dict__["host"] = host
            if instance is None and not opts.urn:
                raise TypeError("Missing required property 'instance'")
            __props__.__dict__["instance"] = instance
            if netmask is None:
                netmask = '255.255.255.255'
            if netmask is None and not opts.urn:
                raise TypeError("Missing required property 'netmask'")
            __props__.__dict__["netmask"] = netmask
            __props__.__dict__["persistence"] = persistence
            if port is None and not opts.urn:
                raise TypeError("Missing required property 'port'")
            __props__.__dict__["port"] = port
            if scheduler is None:
                scheduler = 'wlc'
            if scheduler is None and not opts.urn:
                raise TypeError("Missing required property 'scheduler'")
            __props__.__dict__["scheduler"] = scheduler
            if type is None:
                type = 'tcp'
            if type is None and not opts.urn:
                raise TypeError("Missing required property 'type'")
            __props__.__dict__["type"] = type
        super(Service, __self__).__init__(
            'linux:ipvs:Service',
            resource_name,
            __props__,
            opts,
            remote=True)

    @property
    @pulumi.getter
    def backends(self) -> pulumi.Output[Sequence['outputs.Backend']]:
        return pulumi.get(self, "backends")

    @property
    @pulumi.getter
    def host(self) -> pulumi.Output[str]:
        """
        The host of the service-address. Host may be one of a plain IP address or a hostname.
        """
        return pulumi.get(self, "host")

    @property
    @pulumi.getter
    def netmask(self) -> pulumi.Output[str]:
        """
        Granularity with which clients are grouped for persistent virtual services. The source address of the request is masked with this netmask to direct all clients from a network to the same real server.
        """
        return pulumi.get(self, "netmask")

    @property
    @pulumi.getter
    def persistence(self) -> pulumi.Output[Optional[int]]:
        """
        Virtual service persistence timeout in seconds. Multiple requests from a client are redirected to the same real server selected for the first request.
        """
        return pulumi.get(self, "persistence")

    @property
    @pulumi.getter
    def port(self) -> pulumi.Output[int]:
        """
        The port of the service-address.
        """
        return pulumi.get(self, "port")

    @property
    @pulumi.getter
    def scheduler(self) -> pulumi.Output[str]:
        """
        Algorithm for allocating TCP connections and UDP datagrams to real servers.
        rr - Round Robin: distributes jobs equally amongst the available real servers.
        wrr - Weighted Round Robin: assigns jobs to real servers proportionally to there real servers' weight. Servers with higher weights receive new jobs first and get more jobs than servers with lower weights. Servers with equal weights get an equal distribution of new jobs.
        lc - Least-Connection: assigns more jobs to real servers with fewer active jobs.
        wlc - Weighted Least-Connection: assigns more jobs to servers with fewer jobs and relative to the real servers' weight (Ci/Wi). This is the default.
        lblc - Locality-Based Least-Connection: assigns jobs destined for the same IP address to the same server if the server is not overloaded and available; otherwise assign jobs to servers with fewer jobs, and keep it for future assignment.
        lblcr - Locality-Based Least-Connection with Replication: assigns jobs destined for the same IP address to the least-connection node in the server set for the IP address. If all the node in the server set are over loaded, it picks up a node with fewer jobs in the cluster and adds it in the sever set for the target. If the server set has not been modified for the specified time, the most loaded node is removed from the server set, in order to avoid high degree of replication.
        dh - Destination Hashing: assigns jobs to servers through looking up a statically assigned hash table by their destination IP addresses.
        sh - Source Hashing: assigns jobs to servers through looking up a statically assigned hash table by their source IP addresses.
        sed - Shortest Expected Delay: assigns an incoming job to the server with the shortest expected delay. The expected delay that the job will experience is (Ci + 1) / Ui if sent to the ith server, in which Ci is the number of jobs on the the ith server and Ui is the fixed service rate (weight) of the ith server.
        nq - Never Queue: assigns an incoming job to an idle server if there is, instead of waiting for a fast one; if all the servers are busy, it adopts the Shortest Expected Delay policy to assign the job.
        """
        return pulumi.get(self, "scheduler")

    @property
    @pulumi.getter
    def type(self) -> pulumi.Output[str]:
        """
        Service type, one of the tcp, udp, fwmark
        """
        return pulumi.get(self, "type")

